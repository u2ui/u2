<!DOCTYPE HTML>
<html lang=en>

<head>
    <meta charset="utf-8">
    <meta name=viewport content="width=device-width">
    <title>SelectionManager Tests</title>
    <script src="../../../u2/tests/test-init.js" type=module async></script>
    <script src="../../../u2/auto.js" type=module async></script>

    <link rel=stylesheet href="../../../css/classless/simple.css">

    <style>
        body { font-family: system-ui; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .test-group { margin: 30px 0; padding: 20px; border: 1px solid #ddd; border-radius: 4px; }
        .test-case { margin: 15px 0; padding: 10px; background: #f5f5f5; }
        .pass { color: green; font-weight: bold; }
        .fail { color: red; font-weight: bold; }
        .summary { font-size: 1.2em; margin: 20px 0; padding: 15px; background: #e8f5e9; }
    </style>
</head>

<body>
    <h1>SelectionManager Tests</h1>

    <div id="results"></div>
    <div class="summary" id="summary"></div>

    <script type="module">
        import { SelectionManager } from '../SelectionManager.js';

        // Test Framework
        const groups = [];
        let currentGroup = null;
        
        function group(name) {
            currentGroup = { name, tests: [] };
            groups.push(currentGroup);
        }
        
        function test(name, fn) {
            try {
                fn();
                currentGroup.tests.push({ name, pass: true });
                return true;
            } catch (e) {
                currentGroup.tests.push({ name, pass: false, error: e.message });
                return false;
            }
        }

        function assert(condition, msg) {
            if (!condition) throw new Error(msg || 'Assertion failed');
        }

        function assertEquals(actual, expected, msg) {
            if (actual !== expected) {
                throw new Error(msg || `Expected ${expected}, got ${actual}`);
            }
        }

        function createListbox(items = 3, multi = false) {
            const lb = document.createElement('div');
            lb.role = 'listbox';
            if (multi) lb.ariaMultiSelectable = 'true';
            for (let i = 0; i < items; i++) {
                const opt = document.createElement('div');
                opt.role = 'option';
                opt.textContent = `Item ${i + 1}`;
                lb.appendChild(opt);
            }
            document.body.appendChild(lb);
            return lb;
        }

        // ============================================================================
        // INITIALIZATION & LIFECYCLE
        // ============================================================================
        group('Initialization & Lifecycle');
        
        test('Constructor: Default config', () => {
            const lb = createListbox();
            const sm = new SelectionManager(lb);
            
            assert(sm.container === lb, 'Container set');
            assert(sm.config.preferSingle === false, 'preferSingle default false');
            assert(sm.last !== null, 'last initialized');
            assert(sm.anchor !== null, 'anchor initialized');
            
            sm.destroy();
            lb.remove();
        });

        test('Constructor: Custom config', () => {
            const lb = createListbox();
            const sm = new SelectionManager(lb, { preferSingle: true, custom: 'value' });
            
            assert(sm.config.preferSingle === true, 'preferSingle set');
            assert(sm.config.custom === 'value', 'Extra config preserved');
            
            sm.destroy();
            lb.remove();
        });

        test('Init: First item gets tabIndex=0', () => {
            const lb = createListbox();
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            assertEquals(items[0].tabIndex, 0, 'First item tabIndex=0');
            assertEquals(items[1].tabIndex, -1, 'Second item tabIndex=-1');
            
            sm.destroy();
            lb.remove();
        });

        test('Init: Existing tabIndex=0 preferred over ariaSelected', () => {
            const lb = createListbox();
            const items = Array.from(lb.children);
            items[1].ariaSelected = 'true';
            items[2].tabIndex = 0;
            
            const sm = new SelectionManager(lb);
            
            assertEquals(items[2].tabIndex, 0, 'tabIndex item preferred');
            assert(sm.last === items[2], 'last points to tabIndex item');
            
            sm.destroy();
            lb.remove();
        });

        test('Init: ariaSelected=true item preferred when no tabIndex=0', () => {
            const lb = createListbox();
            const items = Array.from(lb.children);
            items[1].ariaSelected = 'true';
            
            const sm = new SelectionManager(lb);
            
            assertEquals(items[1].tabIndex, 0, 'Selected item gets tabIndex=0');
            assert(sm.last === items[1], 'last points to selected item');
            
            sm.destroy();
            lb.remove();
        });

        test('Init: Empty container', () => {
            const lb = document.createElement('div');
            lb.role = 'listbox';
            document.body.appendChild(lb);
            
            const sm = new SelectionManager(lb);
            
            assert(sm.last === null, 'last is null');
            assert(sm.anchor === null, 'anchor is null');
            assertEquals(sm.items().length, 0, 'No items');
            
            sm.destroy();
            lb.remove();
        });

        test('Destroy: Can be called multiple times', () => {
            const lb = createListbox();
            const sm = new SelectionManager(lb);
            
            sm.destroy();
            sm.destroy(); // Should not throw
            
            lb.remove();
        });

        test('Multi property reflects container attribute', () => {
            const lb = createListbox();
            const sm = new SelectionManager(lb);
            
            assert(sm.multi === false, 'Not multi by default');
            
            lb.ariaMultiSelectable = 'true';
            assert(sm.multi === true, 'Multi when attribute set');
            
            sm.destroy();
            lb.remove();
        });

        // ============================================================================
        // ITEM DETECTION (getOwnItems)
        // ============================================================================
        group('Item Detection (getOwnItems)');

        test('Items: Listbox with options', () => {
            const lb = createListbox(4);
            const sm = new SelectionManager(lb);
            
            assertEquals(sm.items().length, 4, 'Returns all options');
            sm.items().forEach((item, i) => {
                assertEquals(item.role, 'option', `Item ${i} has role option`);
            });
            
            sm.destroy();
            lb.remove();
        });

        test('Items: Different container roles', () => {
            const roles = [
                { container: 'grid', item: 'row' },
                { container: 'tree', item: 'treeitem' },
                { container: 'tablist', item: 'tab' }
            ];
            
            roles.forEach(({ container, item }) => {
                const el = document.createElement('div');
                el.role = container;
                for (let i = 0; i < 3; i++) {
                    const child = document.createElement('div');
                    child.role = item;
                    el.appendChild(child);
                }
                document.body.appendChild(el);
                
                const sm = new SelectionManager(el);
                assertEquals(sm.items().length, 3, `${container} returns all ${item}s`);
                
                sm.destroy();
                el.remove();
            });
        });

        test('Items: Invalid container role returns empty', () => {
            const div = document.createElement('div');
            div.role = 'button';
            document.body.appendChild(div);
            
            const sm = new SelectionManager(div);
            assertEquals(sm.items().length, 0, 'Returns empty array');
            
            sm.destroy();
            div.remove();
        });

        test('Items: Nested containers stop scanning', () => {
            const outerLb = document.createElement('div');
            outerLb.role = 'listbox';
            
            const opt1 = document.createElement('div');
            opt1.role = 'option';
            outerLb.appendChild(opt1);
            
            const innerLb = document.createElement('div');
            innerLb.role = 'listbox';
            const innerOpt = document.createElement('div');
            innerOpt.role = 'option';
            innerLb.appendChild(innerOpt);
            outerLb.appendChild(innerLb);
            
            const opt2 = document.createElement('div');
            opt2.role = 'option';
            outerLb.appendChild(opt2);
            
            document.body.appendChild(outerLb);
            
            const sm = new SelectionManager(outerLb);
            assertEquals(sm.items().length, 2, 'Only outer options found');
            assert(!sm.items().includes(innerOpt), 'Inner option not included');
            
            sm.destroy();
            outerLb.remove();
        });

        test('Items: ariaHidden=true items ignored', () => {
            const lb = createListbox(4);
            const items = Array.from(lb.children);
            items[1].ariaHidden = 'true';
            items[2].ariaHidden = 'true';
            
            const sm = new SelectionManager(lb);
            assertEquals(sm.items().length, 2, 'Only visible items');
            assert(!sm.items().includes(items[1]), 'Hidden item excluded');
            
            sm.destroy();
            lb.remove();
        });

        test('Items: Deep nesting without container role', () => {
            const lb = document.createElement('div');
            lb.role = 'listbox';
            
            const wrapper = document.createElement('div');
            const opt1 = document.createElement('div');
            opt1.role = 'option';
            wrapper.appendChild(opt1);
            lb.appendChild(wrapper);
            
            const opt2 = document.createElement('div');
            opt2.role = 'option';
            lb.appendChild(opt2);
            
            document.body.appendChild(lb);
            
            const sm = new SelectionManager(lb);
            assertEquals(sm.items().length, 2, 'Finds deeply nested items');
            
            sm.destroy();
            lb.remove();
        });

        test('Items: Shadow DOM traversal', () => {
            const lb = document.createElement('div');
            lb.role = 'listbox';
            
            const host = document.createElement('div');
            const shadow = host.attachShadow({ mode: 'open' });
            const opt = document.createElement('div');
            opt.role = 'option';
            shadow.appendChild(opt);
            lb.appendChild(host);
            
            const opt2 = document.createElement('div');
            opt2.role = 'option';
            lb.appendChild(opt2);
            
            document.body.appendChild(lb);
            
            const sm = new SelectionManager(lb);
            assertEquals(sm.items().length, 2, 'Finds shadow DOM items');
            assert(sm.items().includes(opt), 'Shadow option found');
            
            sm.destroy();
            lb.remove();
        });

        // ============================================================================
        // SINGLE SELECTION MODE
        // ============================================================================
        group('Single Selection Mode');

        test('Click selects item exclusively', () => {
            const lb = createListbox(3);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[1].click();
            
            assertEquals(items[0].ariaSelected, 'false', 'First not selected');
            assertEquals(items[1].ariaSelected, 'true', 'Second selected');
            assertEquals(items[2].ariaSelected, 'false', 'Third not selected');
            
            sm.destroy();
            lb.remove();
        });

        test('Click another item deselects previous', () => {
            const lb = createListbox(3);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].click();
            items[2].click();
            
            assertEquals(items[0].ariaSelected, 'false', 'First deselected');
            assertEquals(items[2].ariaSelected, 'true', 'Third selected');
            
            sm.destroy();
            lb.remove();
        });

        test('Modifiers have no effect in single mode', () => {
            const lb = createListbox(3);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].click();
            items[1].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
            
            assertEquals(items[0].ariaSelected, 'false', 'First deselected');
            assertEquals(items[1].ariaSelected, 'true', 'Second selected');
            assertEquals(items.filter(i => i.ariaSelected === 'true').length, 1, 'Only one selected');
            
            sm.destroy();
            lb.remove();
        });

        test('Arrow keys select and move focus', () => {
            const lb = createListbox(3);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].focus();
            items[0].dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowDown', bubbles: true }));
            
            assertEquals(items[0].ariaSelected, 'false', 'First deselected');
            assertEquals(items[1].ariaSelected, 'true', 'Second selected');
            assertEquals(document.activeElement, items[1], 'Focus moved');
            
            items[1].dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowUp', bubbles: true }));
            
            assertEquals(items[0].ariaSelected, 'true', 'First selected again');
            assertEquals(items[1].ariaSelected, 'false', 'Second deselected');
            
            sm.destroy();
            lb.remove();
        });

        test('Home/End select first/last', () => {
            const lb = createListbox(5);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[2].focus();
            items[2].dispatchEvent(new KeyboardEvent('keydown', { key: 'Home', bubbles: true }));
            assertEquals(items[0].ariaSelected, 'true', 'First selected');
            
            items[0].dispatchEvent(new KeyboardEvent('keydown', { key: 'End', bubbles: true }));
            assertEquals(items[4].ariaSelected, 'true', 'Last selected');
            
            sm.destroy();
            lb.remove();
        });

        test('Arrow at boundary stays at boundary', () => {
            const lb = createListbox(3);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].focus();
            items[0].dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowUp', bubbles: true }));
            assertEquals(document.activeElement, items[0], 'Still at first');
            
            sm.focus(items[2]);  // ← Verwende sm.focus() statt items[2].focus()
            items[2].dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowDown', bubbles: true }));
            assertEquals(document.activeElement, items[2], 'Still at last');
            
            sm.destroy();
            lb.remove();
        });

        test('Alt+Arrow is ignored', () => {
            const lb = createListbox(3);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].focus();
            const evt = new KeyboardEvent('keydown', { key: 'ArrowDown', altKey: true, bubbles: true, cancelable: true });
            items[0].dispatchEvent(evt);
            
            assertEquals(document.activeElement, items[0], 'Focus unchanged');
            assert(!evt.defaultPrevented, 'Event not prevented');
            
            sm.destroy();
            lb.remove();
        });

        // ============================================================================
        // MULTI SELECTION MODE
        // ============================================================================
        group('Multi Selection Mode');

        test('Click without modifier toggles selection', () => {
            const lb = createListbox(3, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[1].click();
            assertEquals(items[1].ariaSelected, 'true', 'Item selected');
            
            items[1].click();
            assertEquals(items[1].ariaSelected, 'false', 'Item deselected');
            
            sm.destroy();
            lb.remove();
        });

        test('Click with preferSingle selects exclusively', () => {
            const lb = createListbox(3, true);
            const sm = new SelectionManager(lb, { preferSingle: true });
            const items = sm.items();
            
            items[0].click();
            items[1].click();
            
            assertEquals(items[0].ariaSelected, 'false', 'First deselected');
            assertEquals(items[1].ariaSelected, 'true', 'Second selected');
            
            sm.destroy();
            lb.remove();
        });

        test('Ctrl/Meta+Click toggles and accumulates', () => {
            const lb = createListbox(5, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
            items[2].dispatchEvent(new MouseEvent('click', { metaKey: true, bubbles: true }));
            items[4].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
            
            assertEquals(items[0].ariaSelected, 'true', 'First selected');
            assertEquals(items[2].ariaSelected, 'true', 'Third selected');
            assertEquals(items[4].ariaSelected, 'true', 'Fifth selected');
            
            items[0].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
            assertEquals(items[0].ariaSelected, 'false', 'First deselected');
            
            sm.destroy();
            lb.remove();
        });

        test('Shift+Click creates range selection', () => {
            const lb = createListbox(5, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[1].click();
            items[3].dispatchEvent(new MouseEvent('click', { shiftKey: true, bubbles: true }));
            
            assertEquals(items[0].ariaSelected, 'false', 'Before range');
            assertEquals(items[1].ariaSelected, 'true', 'Range start');
            assertEquals(items[2].ariaSelected, 'true', 'Range middle');
            assertEquals(items[3].ariaSelected, 'true', 'Range end');
            assertEquals(items[4].ariaSelected, 'false', 'After range');
            
            sm.destroy();
            lb.remove();
        });

        test('Shift+Click backward range', () => {
            const lb = createListbox(5, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[3].click();
            items[1].dispatchEvent(new MouseEvent('click', { shiftKey: true, bubbles: true }));
            
            assertEquals(items[1].ariaSelected, 'true', 'Range start');
            assertEquals(items[2].ariaSelected, 'true', 'Range middle');
            assertEquals(items[3].ariaSelected, 'true', 'Range end');
            
            sm.destroy();
            lb.remove();
        });

        test('Shift+Click clears previous selection', () => {
            const lb = createListbox(7, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
            items[6].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
            items[2].click();
            items[4].dispatchEvent(new MouseEvent('click', { shiftKey: true, bubbles: true }));
            
            assertEquals(items[0].ariaSelected, 'false', 'Old selection cleared');
            assertEquals(items[2].ariaSelected, 'true', 'New range start');
            assertEquals(items[4].ariaSelected, 'true', 'New range end');
            assertEquals(items[6].ariaSelected, 'false', 'Old selection cleared');
            
            sm.destroy();
            lb.remove();
        });

        test('Arrow without Shift moves focus only', () => {
            const lb = createListbox(4, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[1].click();
            items[1].dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowDown', bubbles: true }));
            
            assertEquals(items[1].ariaSelected, 'true', 'Previous selection kept');
            assertEquals(items[2].ariaSelected, null, 'New focus not selected');
            assertEquals(document.activeElement, items[2], 'Focus moved');
            
            sm.destroy();
            lb.remove();
        });

        test('Shift+Arrow extends selection', () => {
            const lb = createListbox(5, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[1].click();
            items[1].dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowDown', shiftKey: true, bubbles: true }));
            items[2].dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowDown', shiftKey: true, bubbles: true }));
            
            assertEquals(items[1].ariaSelected, 'true', 'Anchor');
            assertEquals(items[2].ariaSelected, 'true', 'Extended');
            assertEquals(items[3].ariaSelected, 'true', 'Extended');
            
            sm.destroy();
            lb.remove();
        });

        test('Space toggles current item', () => {
            const lb = createListbox(3, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            sm.focus(items[1]);
            items[1].dispatchEvent(new KeyboardEvent('keydown', { key: ' ', bubbles: true }));
            assertEquals(items[1].ariaSelected, 'true', 'Selected');
            
            items[1].dispatchEvent(new KeyboardEvent('keydown', { key: ' ', bubbles: true }));
            assertEquals(items[1].ariaSelected, 'false', 'Deselected');
            
            sm.destroy();
            lb.remove();
        });

        test('Shift+Space creates range', () => {
            const lb = createListbox(5, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[1].click();
            sm.focus(items[3]);
            items[3].dispatchEvent(new KeyboardEvent('keydown', { key: ' ', shiftKey: true, bubbles: true }));
            
            assertEquals(items[1].ariaSelected, 'true', 'Range start');
            assertEquals(items[2].ariaSelected, 'true', 'Range middle');
            assertEquals(items[3].ariaSelected, 'true', 'Range end');
            
            sm.destroy();
            lb.remove();
        });

        test('Ctrl/Meta+A selects all', () => {
            const lb = createListbox(4, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].dispatchEvent(new KeyboardEvent('keydown', { key: 'a', ctrlKey: true, bubbles: true }));
            
            items.forEach(item => {
                assertEquals(item.ariaSelected, 'true', 'All selected');
            });
            
            sm.destroy();
            lb.remove();
        });

        test('Ctrl+A has no effect in single mode', () => {
            const lb = createListbox(3);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].dispatchEvent(new KeyboardEvent('keydown', { key: 'a', ctrlKey: true, bubbles: true }));
            
            const selectedCount = items.filter(i => i.ariaSelected === 'true').length;
            assert(selectedCount <= 1, 'Not all selected in single mode');
            
            sm.destroy();
            lb.remove();
        });

        test('Enter selects only current (clears others)', () => {
            const lb = createListbox(4, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[0].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
            items[2].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
            
            sm.focus(items[1]);
            items[1].dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));
            
            assertEquals(items[0].ariaSelected, 'false', 'First deselected');
            assertEquals(items[1].ariaSelected, 'true', 'Focused selected');
            assertEquals(items[2].ariaSelected, 'false', 'Third deselected');
            
            sm.destroy();
            lb.remove();
        });

        test('Range direction change from anchor', () => {
            const lb = createListbox(7, true);
            const sm = new SelectionManager(lb);
            const items = sm.items();
            
            items[3].click();
            items[5].dispatchEvent(new MouseEvent('click', { shiftKey: true, bubbles: true }));
            
            assertEquals(items[3].ariaSelected, 'true', 'Anchor');
            assertEquals(items[4].ariaSelected, 'true', 'Forward');
            assertEquals(items[5].ariaSelected, 'true', 'Forward');
            
            items[1].dispatchEvent(new MouseEvent('click', { shiftKey: true, bubbles: true }));
            
            assertEquals(items[1].ariaSelected, 'true', 'Backward');
            assertEquals(items[2].ariaSelected, 'true', 'Backward');
            assertEquals(items[3].ariaSelected, 'true', 'Anchor');
            assertEquals(items[4].ariaSelected, 'false', 'Old cleared');
            assertEquals(items[5].ariaSelected, 'false', 'Old cleared');
            
            sm.destroy();
            lb.remove();
        });



group('Focus Management');

test('Focus: Moving tabIndex when changing focus', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    assertEquals(items[0].tabIndex, 0, 'First has tabIndex=0');
    
    sm.focus(items[2]);
    
    assertEquals(items[0].tabIndex, -1, 'First lost tabIndex');
    assertEquals(items[2].tabIndex, 0, 'Third gained tabIndex');
    assertEquals(sm.last, items[2], 'last updated');
    
    sm.destroy();
    lb.remove();
});

test('Focus: Updates last pointer', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    const initial = sm.last;
    sm.focus(items[1]);
    
    assert(sm.last !== initial, 'last changed');
    assert(sm.last === items[1], 'last points to new item');
    
    sm.destroy();
    lb.remove();
});






group('Anchor Management');

test('Anchor: Set on click in multi mode', () => {
    const lb = createListbox(3, true);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[1].click();
    assertEquals(sm.anchor, items[1], 'Anchor set to clicked item');
    
    sm.destroy();
    lb.remove();
});

test('Anchor: Set on toggle in multi mode', () => {
    const lb = createListbox(3, true);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].dispatchEvent(new MouseEvent('click', { ctrlKey: true, bubbles: true }));
    assertEquals(sm.anchor, items[0], 'Anchor set on Ctrl+Click');
    
    sm.destroy();
    lb.remove();
});

test('Anchor: Used for range selection', () => {
    const lb = createListbox(5, true);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[1].click();
    const anchor = sm.anchor;
    
    items[3].dispatchEvent(new MouseEvent('click', { shiftKey: true, bubbles: true }));
    
    assertEquals(sm.anchor, anchor, 'Anchor unchanged during range');
    
    sm.destroy();
    lb.remove();
});




group('Selection Methods');

test('add: Sets ariaSelected to true', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    sm.add(items[1]);
    assertEquals(items[1].ariaSelected, 'true', 'Item selected');
    
    sm.destroy();
    lb.remove();
});

test('remove: Sets ariaSelected to false', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[1].ariaSelected = 'true';
    sm.remove(items[1]);
    assertEquals(items[1].ariaSelected, 'false', 'Item deselected');
    
    sm.destroy();
    lb.remove();
});

test('clear: Deselects all items', () => {
    const lb = createListbox(3, true);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].ariaSelected = 'true';
    items[1].ariaSelected = 'true';
    items[2].ariaSelected = 'true';
    
    sm.clear();
    
    items.forEach(item => {
        assertEquals(item.ariaSelected, 'false', 'All deselected');
    });
    
    sm.destroy();
    lb.remove();
});

test('toggle: Toggles from false to true', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    sm.toggle(items[1]);
    assertEquals(items[1].ariaSelected, 'true', 'Toggled to true');
    assertEquals(sm.anchor, items[1], 'Anchor set');
    
    sm.destroy();
    lb.remove();
});

test('toggle: Toggles from true to false', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[1].ariaSelected = 'true';
    sm.toggle(items[1]);
    assertEquals(items[1].ariaSelected, 'false', 'Toggled to false');
    
    sm.destroy();
    lb.remove();
});

test('only: Selects one and clears others', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].ariaSelected = 'true';
    items[2].ariaSelected = 'true';
    
    sm.only(items[1]);
    
    assertEquals(items[0].ariaSelected, 'false', 'First cleared');
    assertEquals(items[1].ariaSelected, 'true', 'Middle selected');
    assertEquals(items[2].ariaSelected, 'false', 'Last cleared');
    assertEquals(sm.anchor, items[1], 'Anchor set');
    
    sm.destroy();
    lb.remove();
});





group('Range Selection Details');

test('range: Works on empty list', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    sm.range(items[0], items[2]);
    
    assertEquals(items[0].ariaSelected, 'true', 'Start selected');
    assertEquals(items[1].ariaSelected, 'true', 'Middle selected');
    assertEquals(items[2].ariaSelected, 'true', 'End selected');
    
    sm.destroy();
    lb.remove();
});

test('range: Same item range', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    sm.range(items[1], items[1]);
    
    assert(items[0].ariaSelected !== 'true', 'Before not selected');
    assertEquals(items[1].ariaSelected, 'true', 'Single item selected');
    assert(items[2].ariaSelected !== 'true', 'After not selected');
    
    sm.destroy();
    lb.remove();
});



group('Edge Cases');

test('Click on non-item element does nothing', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].ariaSelected = 'true';
    
    // Click on container itself
    lb.click();
    
    assertEquals(items[0].ariaSelected, 'true', 'Selection unchanged');
    
    sm.destroy();
    lb.remove();
});

test('Keyboard navigation when no item focused', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    document.body.focus(); // Focus away from listbox
    
    const evt = new KeyboardEvent('keydown', { key: 'ArrowDown', bubbles: true });
    lb.dispatchEvent(evt);
    
    // Should handle gracefully
    assert(true, 'Does not crash');
    
    sm.destroy();
    lb.remove();
});

test('Dynamic items: Items added after init', () => {
    const lb = createListbox(2);
    const sm = new SelectionManager(lb);
    
    const newOpt = document.createElement('div');
    newOpt.role = 'option';
    newOpt.textContent = 'New item';
    lb.appendChild(newOpt);
    
    const items = sm.items();
    assertEquals(items.length, 3, 'New item found');
    
    sm.destroy();
    lb.remove();
});

test('Selection with Shift but no anchor uses fallback', () => {
    const lb = createListbox(5, true);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    sm.anchor = null; // Clear anchor
    
    sm.focus(items[2]);
    items[2].dispatchEvent(new KeyboardEvent('keydown', { key: ' ', shiftKey: true, bubbles: true }));
    
    // Should use items[0] as fallback or current item
    assert(items[2].ariaSelected === 'true', 'Handles missing anchor');
    
    sm.destroy();
    lb.remove();
});




group('Event Handling');

test('Click event uses composedPath', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    // Create nested element inside option
    const span = document.createElement('span');
    span.textContent = 'Click me';
    items[1].appendChild(span);
    
    span.click();
    
    assertEquals(items[1].ariaSelected, 'true', 'Parent option selected');
    
    sm.destroy();
    lb.remove();
});

test('preventDefault called on handled keys', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].focus();
    const evt = new KeyboardEvent('keydown', { key: 'ArrowDown', bubbles: true, cancelable: true });
    items[0].dispatchEvent(evt);
    
    assert(evt.defaultPrevented, 'Event prevented');
    
    sm.destroy();
    lb.remove();
});



group('Initialization Edge Cases');

test('Init: First selected item preferred over later ones', () => {
    const lb = createListbox(4);
    const items = Array.from(lb.children);
    items[1].ariaSelected = 'true';
    items[2].ariaSelected = 'true';
    
    const sm = new SelectionManager(lb);
    
    assertEquals(sm.last, items[1], 'First selected item chosen');
    
    sm.destroy();
    lb.remove();
});


group('Accessibility & ARIA');


test('ARIA: Only one item has tabIndex=0 at a time', () => {
    const lb = createListbox(5);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    sm.focus(items[2]);
    
    const tabIndex0Count = items.filter(i => i.tabIndex === 0).length;
    assertEquals(tabIndex0Count, 1, 'Exactly one item has tabIndex=0');
    
    sm.destroy();
    lb.remove();
});



group('Stress Tests');

test('Large list: 100 items', () => {
    const lb = createListbox(100);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    assertEquals(items.length, 100, '100 items found');
    
    items[0].focus();
    items[0].dispatchEvent(new KeyboardEvent('keydown', { key: 'End', bubbles: true }));
    
    assertEquals(document.activeElement, items[99], 'Can navigate to end');
    
    sm.destroy();
    lb.remove();
});

test('Rapid selection changes', () => {
    const lb = createListbox(5, true);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    // Rapid clicks
    for (let i = 0; i < 100; i++) {
        items[i % 5].dispatchEvent(new MouseEvent('click', { 
            ctrlKey: true, 
            bubbles: true 
        }));
    }
    
    assert(true, 'Handles rapid changes without crashing');
    
    sm.destroy();
    lb.remove();
});



group('Container Type Specifics');

test('Grid: Works with rows', () => {
    const grid = document.createElement('div');
    grid.role = 'grid';
    
    for (let i = 0; i < 3; i++) {
        const row = document.createElement('div');
        row.role = 'row';
        row.textContent = `Row ${i + 1}`;
        grid.appendChild(row);
    }
    document.body.appendChild(grid);
    
    const sm = new SelectionManager(grid);
    const items = sm.items();
    
    assertEquals(items.length, 3, 'Found all rows');
    items[0].click();
    assertEquals(items[0].ariaSelected, 'true', 'Row selected');
    
    sm.destroy();
    grid.remove();
});

test('Grid: Works with gridcells', () => {
    const grid = document.createElement('div');
    grid.role = 'grid';
    
    for (let i = 0; i < 3; i++) {
        const cell = document.createElement('div');
        cell.role = 'gridcell';
        cell.textContent = `Cell ${i + 1}`;
        grid.appendChild(cell);
    }
    document.body.appendChild(grid);
    
    const sm = new SelectionManager(grid);
    const items = sm.items();
    
    assertEquals(items.length, 3, 'Found all gridcells');
    items[0].click();
    assertEquals(items[0].ariaSelected, 'true', 'Cell selected');
    
    sm.destroy();
    grid.remove();
});


test('Treegrid: Handles both row and gridcell', () => {
    const grid = document.createElement('div');
    grid.role = 'treegrid';
    
    const row = document.createElement('div');
    row.role = 'row';
    grid.appendChild(row);
    
    const cell = document.createElement('div');
    cell.role = 'gridcell';
    grid.appendChild(cell);
    
    document.body.appendChild(grid);
    
    const sm = new SelectionManager(grid);
    assertEquals(sm.items().length, 2, 'Both row and gridcell found');
    
    sm.destroy();
    grid.remove();
});



group('Memory & Cleanup');

test('Destroy: Removes event listeners properly', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    
    let clickCount = 0;
    const counter = () => clickCount++;
    lb.addEventListener('click', counter);
    
    sm.destroy();
    
    lb.children[0].click();
    const afterDestroy = clickCount;
    
    assert(afterDestroy > 0, 'External listeners still work');
    
    lb.removeEventListener('click', counter);
    lb.remove();
});

test('Multiple SelectionManagers on same container (error case)', () => {
    const lb = createListbox(3);
    const sm1 = new SelectionManager(lb);
    const sm2 = new SelectionManager(lb);
    
    // Both should work independently (though not recommended)
    const items = sm1.items();
    items[0].click();
    
    assert(true, 'Does not crash with multiple managers');
    
    sm1.destroy();
    sm2.destroy();
    lb.remove();
});



group('Complex Scenarios');

test('Multi: Select all, then deselect one', () => {
    const lb = createListbox(5, true);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].dispatchEvent(new KeyboardEvent('keydown', { 
        key: 'a', 
        ctrlKey: true, 
        bubbles: true 
    }));
    
    items[2].dispatchEvent(new MouseEvent('click', { 
        ctrlKey: true, 
        bubbles: true 
    }));
    
    assertEquals(items[0].ariaSelected, 'true', 'First still selected');
    assertEquals(items[2].ariaSelected, 'false', 'Middle deselected');
    assertEquals(items[4].ariaSelected, 'true', 'Last still selected');
    
    sm.destroy();
    lb.remove();
});

test('Multi: Overlapping ranges', () => {
    const lb = createListbox(7, true);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[1].click();
    items[3].dispatchEvent(new MouseEvent('click', { 
        shiftKey: true, 
        bubbles: true 
    }));
    
    // Items 1-3 selected
    
    items[2].click(); // New anchor
    items[5].dispatchEvent(new MouseEvent('click', { 
        shiftKey: true, 
        bubbles: true 
    }));
    
    // Should clear and select 2-5
    assertEquals(items[1].ariaSelected, 'false', 'Old range cleared');
    assertEquals(items[2].ariaSelected, 'true', 'New anchor');
    assertEquals(items[5].ariaSelected, 'true', 'New range end');
    
    sm.destroy();
    lb.remove();
});

test('Navigation wrapping at boundaries (stays put)', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].focus();
    for (let i = 0; i < 5; i++) {
        items[0].dispatchEvent(new KeyboardEvent('keydown', { 
            key: 'ArrowUp', 
            bubbles: true 
        }));
    }
    
    assertEquals(document.activeElement, items[0], 'Still at first after multiple ArrowUp');
    
    sm.focus(items[2]);
    for (let i = 0; i < 5; i++) {
        items[2].dispatchEvent(new KeyboardEvent('keydown', { 
            key: 'ArrowDown', 
            bubbles: true 
        }));
    }
    
    assertEquals(document.activeElement, items[2], 'Still at last after multiple ArrowDown');
    
    sm.destroy();
    lb.remove();
});

test('Switch from single to multi mode dynamically', () => {
    const lb = createListbox(4);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].click();
    items[1].click();
    assertEquals(items[0].ariaSelected, 'false', 'Single mode: only one selected');
    
    lb.ariaMultiSelectable = 'true';
    
    items[2].dispatchEvent(new MouseEvent('click', { 
        ctrlKey: true, 
        bubbles: true 
    }));
    
    const selectedCount = items.filter(i => i.ariaSelected === 'true').length;
    assert(selectedCount >= 2, 'Multi mode: multiple selected');
    
    sm.destroy();
    lb.remove();
});



group('Error Handling');

test('Invalid item passed to methods', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    
    const fakeItem = document.createElement('div');
    fakeItem.role = 'option';
    
    // Should handle gracefully
    try {
        sm.focus(fakeItem);
        sm.add(fakeItem);
        sm.toggle(fakeItem);
        assert(true, 'Handles invalid items gracefully');
    } catch (e) {
        assert(false, 'Should not throw on invalid items');
    }
    
    sm.destroy();
    lb.remove();
});

test('Events after destroy are ignored', () => {
    const lb = createListbox(3);
    const sm = new SelectionManager(lb);
    const items = sm.items();
    
    items[0].ariaSelected = 'true';
    sm.destroy();
    
    items[1].click();
    
    assertEquals(items[0].ariaSelected, 'true', 'Selection unchanged after destroy');
    
    lb.remove();
});

        // ============================================================================
        // Display Results
        // ============================================================================
        const resultsDiv = document.getElementById('results');
        let passed = 0, failed = 0;

        groups.forEach(g => {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'test-group';
            groupDiv.innerHTML = `<h3>${g.name}</h3>`;
            
            g.tests.forEach(r => {
                const div = document.createElement('div');
                div.className = 'test-case';
                div.innerHTML = `
                    <span class="${r.pass ? 'pass' : 'fail'}">${r.pass ? '✓' : '✗'}</span>
                    ${r.name}
                    ${r.error ? `<br><small style="color: red;">${r.error}</small>` : ''}
                `;
                groupDiv.appendChild(div);
                r.pass ? passed++ : failed++;
            });
            
            resultsDiv.appendChild(groupDiv);
        });

        const total = passed + failed;
        document.getElementById('summary').innerHTML = `
            <strong>Tests: ${total}</strong> | 
            <span style="color: green;">Passed: ${passed}</span> | 
            <span style="color: red;">Failed: ${failed}</span>
        `;
    </script>

